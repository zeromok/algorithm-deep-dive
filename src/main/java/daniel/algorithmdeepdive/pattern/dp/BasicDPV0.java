package daniel.algorithmdeepdive.pattern.dp;

/// # DP 패턴 V0 - 재귀만 (DP 없음)
/// ## 핵심 원리
/// - 재귀 호출로 모든 경우를 탐색
/// - 중복 계산이 발생하여 비효율적
/// - DP의 필요성을 보여주는 단계
///
/// ## 시간 복잡도: 지수 시간 (중복 계산)
/// ## 공간 복잡도: O(재귀 깊이)
///
/// ## 학습 포인트
/// - 재귀 구조로 문제를 분해하는 방법
/// - 중복 계산이 발생하는 이유 이해
/// - DP가 필요한 이유를 체감
public class BasicDPV0 {

	/// 재귀만 사용한 해결 (DP 없음)
	///
	/// 점화식: f(n) = f(n-1) + f(n-2)
	/// 기저 조건: f(0) = 0, f(1) = 1
	///
	/// 문제: 같은 값을 여러 번 계산함
	/// 예: f(5) = f(4) + f(3)
	///     f(4) = f(3) + f(2)  <- f(3) 중복 계산
	///     f(3) = f(2) + f(1)  <- f(2) 중복 계산
	///
	/// @param n 계산할 인덱스
	/// @return n번째 피보나치 수
	public static int fibonacci(int n) {
		// 종료 조건: 가장 작은 문제
		if (n <= 1) {
			return n;
		}

		// 점화식: 큰 문제를 작은 문제로 나누어 해결
		return fibonacci(n - 1) + fibonacci(n - 2);
	}
}
